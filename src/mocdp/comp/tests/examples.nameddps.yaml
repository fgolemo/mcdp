# - id: battery_open
#   desc: ""
#   code:
#   - mocdp.comp.dpconnect
#   - name2dp: 
#       times: energy_times
#       battery: battery
#       actuation:
#       - mocdp.comp.SimpleWrap
#       - fnames: weight
#         rnames: actuation_power
#         dp: ['mocdp.example_battery.Mobility', {}]
#     connections:
#     - 'times.power >= actuation.actuation_power'
#     - 'battery.capacity >= times.energy'


# - id: battery_complete
#   desc: ""
#   code:
#   - mocdp.comp.dpgraph
#   - name2dp: 
#       times: energy_times
#       battery: battery
#       actuation:
#       - mocdp.comp.SimpleWrap
#       - fnames: weight
#         rnames: actuation_power
#         dp: ['mocdp.example_battery.Mobility', {}]
#     connections:
#     - 'times.power >= actuation.actuation_power'
#     - 'battery.capacity >= times.energy'
#     - 'actuation.weight >= battery.battery_weight'
#     split: []

- id: energy_times
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: ['mission_time', 'power']
    rnames: 'energy'
    dp: energy_product

- id: battery
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: 'capacity'
    rnames: 'battery_weight'
    dp: BatteryDP

# - id: maxh
#   desc: ""
#   code:
#   - mocdp.comp.dpgraph
#   - name2dp: 
#       max: max_f_r
#       h: hnlin
#     connections:
#     - 'h.x >= max.z'
#     - 'max.r >= h.r'
#     split: []

- id: max_f_r
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: ['f', 'r']
    rnames: 'z'
    dp: 
    - mocdp.dp.Max
    - F: Rcomp_J

- id: hnlin
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: 'x'
    rnames: 'r'
    dp: SimpleNonlinearity1

# - id: minh
#   desc: ""
#   code:
#   - mocdp.comp.dpgraph
#   - name2dp: 
#       min: min_f_r
#       h: hnlin
#     connections:
#     - 'h.x >= min.z'
#     - 'min.r >= h.r'
#     split: []

- id: min_f_r
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: ['f', 'r']
    rnames: 'z'
    dp: 
    - mocdp.dp.Min
    - F: Rcomp_J

- id: mobility
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: weight
    rnames: actuation_power
    dp: ['mocdp.example_battery.Mobility', {}]

- id: battery_complete_parsed
  desc: ""
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      mcdp {
          #
          provides x [s]                                                                      
          #
          sub battery = instance load battery
          sub times = instance load energy_times
          sub actuation = instance load mobility
          #
          times.mission_time >= x
          #     
          times.power >= actuation.actuation_power
          battery.capacity >= times.energy
          actuation.weight >= battery.battery_weight
      }


- id: testmax
  desc: "Test with max"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      mcdp {
          provides f [R]
          
          sub hnlin = instance dp {
              provides x [R]
              requires r [R]
              
              implemented-by load SimpleNonlinearity1
          }
          
          hnlin.x >= max(f, hnlin.r)        
      }

- id: testmin
  desc: "Test with min"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      mcdp {
          provides f [R]
          
          sub hnlin = instance dp {
              provides x [R]
              requires r [R]
              
              implemented-by load SimpleNonlinearity1
          }
          
          hnlin.x >= min(f, hnlin.r)        
      }

- id: testminsq
  desc: "Test with min"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      mcdp {
        provides f0 [R]
        sub DP = instance mcdp {
            provides f [R]
            requires r2 [R]
            
            sub hnlin = instance dp {
                provides x [R]
                requires r [R]
               
                implemented-by load SimpleNonlinearity1
            }
            
            hnlin.x >= min(f, hnlin.r)        
            r2 >= hnlin.r
        }
        DP.f >= max(f0, DP.r2)
      }

- id: testminsq_2
  desc: "Equivalent, just switching the order of arguments to max"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      mcdp {
        provides f0 [R]
        sub DP = mcdp {
            provides f [R]
            requires r2 [R]
            
            sub hnlin = dp {
                provides x [R]
                requires r [R]
                
                implemented-by load SimpleNonlinearity1
            }
            
            hnlin.x >= min(f, hnlin.r)  
            r2 >= hnlin.r      
        }
        DP.f >= max(DP.r2, f0)
      }


- id: testminsq_3
  desc: "Equivalent, just switching the order of arguments to max"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      mcdp {
        provides f0 [R]
        sub DP = mcdp {
            provides f [R]
            requires r2 [R]
            
            sub hnlin = instance dp {
                provides x [R]
                requires r [R]
                
                implemented-by load SimpleNonlinearity1
            }
            
            hnlin.x >= min(hnlin.r, f)        
            r2 >= hnlin.r
        }
        DP.f >= max(DP.r2, f0)
      }

- id: testlang13_diagram
  desc: "Diagram in the presentation"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      mcdp {
          provides cargo [g]
          requires total_weight [g]
          #
          sub battery = instance dp {
              provides capacity [J]
              requires battery_weight [kg]
              
              implemented-by load BatteryDP
          }
          #
          sub actuation = instance dp {
              provides weight [g]
              requires actuation_power [W]
              
              implemented-by code mocdp.example_battery.Mobility
          }
          #
          sub sensing = instance dp {
          #
              requires sensing_power [W]
              requires mission_time [s]
          #    
              implemented-by code mocdp.example_battery.PowerTimeTradeoff
          }
          #
          (capacity provided by battery) >= sensing.mission_time  * (actuation.actuation_power + sensing.sensing_power)
          cargo + (battery_weight required by battery) <= weight provided by actuation
          #
          total_weight >= cargo + (battery_weight required by battery)
      }
